<Comment># Original: https://learnxinyminutes.com/docs/elixir/</Comment><br/>
<Normal Text></Normal Text><br/>
<Comment># Single line comments start with a number symbol.</Comment><br/>
<Normal Text></Normal Text><br/>
<Comment># There's no multi-line comment,</Comment><br/>
<Comment># but you can stack multiple comments.</Comment><br/>
<Normal Text></Normal Text><br/>
<Comment># To use the elixir shell use the `iex` command.</Comment><br/>
<Comment># Compile your modules with the `elixirc` command.</Comment><br/>
<Normal Text></Normal Text><br/>
<Comment># Both should be in your path if you installed elixir correctly.</Comment><br/>
<Normal Text></Normal Text><br/>
<Comment>## ---------------------------</Comment><br/>
<Comment>## -- Basic types</Comment><br/>
<Comment>## ---------------------------</Comment><br/>
<Normal Text></Normal Text><br/>
<Comment># There are numbers</Comment><br/>
<Dec>3</Dec><Normal Text>    </Normal Text><Comment># integer</Comment><br/>
<Hex>0x1F</Hex><Normal Text> </Normal Text><Comment># integer</Comment><br/>
<Float>3.0</Float><Normal Text>  </Normal Text><Comment># float</Comment><br/>
<Normal Text></Normal Text><br/>
<Comment># Atoms, that are literals, a constant with name. They start with `:`.</Comment><br/>
<Symbol>:hello</Symbol><Normal Text> </Normal Text><Comment># atom</Comment><br/>
<Normal Text></Normal Text><br/>
<Comment># Tuples that are stored contiguously in memory.</Comment><br/>
<Normal Text>{</Normal Text><Dec>1</Dec><Normal Text>,</Normal Text><Dec>2</Dec><Normal Text>,</Normal Text><Dec>3</Dec><Normal Text>} </Normal Text><Comment># tuple</Comment><br/>
<Normal Text></Normal Text><br/>
<Comment># We can access a tuple element with the `elem` function:</Comment><br/>
<Normal Text>elem({</Normal Text><Dec>1</Dec><Normal Text>, </Normal Text><Dec>2</Dec><Normal Text>, </Normal Text><Dec>3</Dec><Normal Text>}, </Normal Text><Dec>0</Dec><Normal Text>) </Normal Text><Comment>#=> 1</Comment><br/>
<Normal Text></Normal Text><br/>
<Comment># Lists that are implemented as linked lists.</Comment><br/>
<Delimiter>[</Delimiter><Dec>1</Dec><Normal Text>,</Normal Text><Dec>2</Dec><Normal Text>,</Normal Text><Dec>3</Dec><Delimiter>]</Delimiter><Normal Text> </Normal Text><Comment># list</Comment><br/>
<Normal Text></Normal Text><br/>
<Comment># We can access the head and tail of a list as follows:</Comment><br/>
<Delimiter>[</Delimiter><Normal Text>head </Normal Text><Operator>|</Operator><Normal Text> tail</Normal Text><Delimiter>]</Delimiter><Normal Text> </Normal Text><Operator>=</Operator><Normal Text> </Normal Text><Delimiter>[</Delimiter><Dec>1</Dec><Normal Text>,</Normal Text><Dec>2</Dec><Normal Text>,</Normal Text><Dec>3</Dec><Delimiter>]</Delimiter><br/>
<Normal Text>head </Normal Text><Comment>#=> 1</Comment><br/>
<Normal Text>tail </Normal Text><Comment>#=> [2,3]</Comment><br/>
<Normal Text></Normal Text><br/>
<Comment># In elixir, just like in Erlang, the `=` denotes pattern matching and</Comment><br/>
<Comment># not an assignment.</Comment><br/>
<Comment>#</Comment><br/>
<Comment># This means that the left-hand side (pattern) is matched against a</Comment><br/>
<Comment># right-hand side.</Comment><br/>
<Comment>#</Comment><br/>
<Comment># This is how the above example of accessing the head and tail of a list works.</Comment><br/>
<Normal Text></Normal Text><br/>
<Comment># A pattern match will error when the sides don't match, in this example</Comment><br/>
<Comment># the tuples have different sizes.</Comment><br/>
<Comment># {a, b, c} = {1, 2} #=> ** (MatchError) no match of right hand side value: {1,2}</Comment><br/>
<Normal Text></Normal Text><br/>
<Comment># There are also binaries</Comment><br/>
<Operator><<</Operator><Dec>1</Dec><Normal Text>,</Normal Text><Dec>2</Dec><Normal Text>,</Normal Text><Dec>3</Dec><Operator>>></Operator><Normal Text> </Normal Text><Comment># binary</Comment><br/>
<Normal Text></Normal Text><br/>
<Comment># Strings and char lists</Comment><br/>
<String>"hello"</String><Normal Text> </Normal Text><Comment># string</Comment><br/>
<Raw String>'hello'</Raw String><Normal Text> </Normal Text><Comment># char list</Comment><br/>
<Normal Text></Normal Text><br/>
<Comment># Multi-line strings</Comment><br/>
<String>"""</String><br/>
<String>I'm a multi-line</String><br/>
<String>string.</String><br/>
<String>"""</String><br/>
<Comment>#=> "I'm a multi-line\nstring.\n"</Comment><br/>
<Normal Text></Normal Text><br/>
<Comment># Strings are all encoded in UTF-8:</Comment><br/>
<String>"héllò"</String><Normal Text> </Normal Text><Comment>#=> "héllò"</Comment><br/>
<Normal Text></Normal Text><br/>
<Comment># Strings are really just binaries, and char lists are just lists.</Comment><br/>
<Operator><<</Operator><Normal Text>?a, ?b, ?c</Normal Text><Operator>>></Operator><Normal Text> </Normal Text><Comment>#=> "abc"</Comment><br/>
<Delimiter>[</Delimiter><Normal Text>?a, ?b, ?c</Normal Text><Delimiter>]</Delimiter><Normal Text>   </Normal Text><Comment>#=> 'abc'</Comment><br/>
<Normal Text></Normal Text><br/>
<Comment># `?a` in elixir returns the ASCII integer for the letter `a`</Comment><br/>
<Normal Text>?a </Normal Text><Comment>#=> 97</Comment><br/>
<Normal Text></Normal Text><br/>
<Comment># To concatenate lists use `++`, for binaries use `<>`</Comment><br/>
<Delimiter>[</Delimiter><Dec>1</Dec><Normal Text>,</Normal Text><Dec>2</Dec><Normal Text>,</Normal Text><Dec>3</Dec><Delimiter>]</Delimiter><Normal Text> </Normal Text><Operator>++</Operator><Normal Text> </Normal Text><Delimiter>[</Delimiter><Dec>4</Dec><Normal Text>,</Normal Text><Dec>5</Dec><Delimiter>]</Delimiter><Normal Text>     </Normal Text><Comment>#=> [1,2,3,4,5]</Comment><br/>
<Raw String>'hello '</Raw String><Normal Text> </Normal Text><Operator>++</Operator><Normal Text> </Normal Text><Raw String>'world'</Raw String><Normal Text>  </Normal Text><Comment>#=> 'hello world'</Comment><br/>
<Normal Text></Normal Text><br/>
<Operator><<</Operator><Dec>1</Dec><Normal Text>,</Normal Text><Dec>2</Dec><Normal Text>,</Normal Text><Dec>3</Dec><Operator>>></Operator><Normal Text> </Normal Text><Operator><></Operator><Normal Text> </Normal Text><Operator><<</Operator><Dec>4</Dec><Normal Text>,</Normal Text><Dec>5</Dec><Operator>>></Operator><Normal Text> </Normal Text><Comment>#=> <<1,2,3,4,5>></Comment><br/>
<String>"hello "</String><Normal Text> </Normal Text><Operator><></Operator><Normal Text> </Normal Text><String>"world"</String><Normal Text>  </Normal Text><Comment>#=> "hello world"</Comment><br/>
<Normal Text></Normal Text><br/>
<Comment># Ranges are represented as `start..end` (both inclusive)</Comment><br/>
<Dec>1</Dec><Operator>..</Operator><Dec>10</Dec><Normal Text> </Normal Text><Comment>#=> 1..10</Comment><br/>
<Normal Text>lower</Normal Text><Operator>..</Operator><Normal Text>upper </Normal Text><Operator>=</Operator><Normal Text> </Normal Text><Dec>1</Dec><Operator>..</Operator><Dec>10</Dec><Normal Text> </Normal Text><Comment># Can use pattern matching on ranges as well</Comment><br/>
<Delimiter>[</Delimiter><Normal Text>lower, upper</Normal Text><Delimiter>]</Delimiter><Normal Text> </Normal Text><Comment>#=> [1, 10]</Comment><br/>
<Normal Text></Normal Text><br/>
<Comment>## ---------------------------</Comment><br/>
<Comment>## -- Operators</Comment><br/>
<Comment>## ---------------------------</Comment><br/>
<Normal Text></Normal Text><br/>
<Comment># Some math</Comment><br/>
<Dec>1</Dec><Normal Text> </Normal Text><Operator>+</Operator><Normal Text> </Normal Text><Dec>1</Dec><Normal Text>  </Normal Text><Comment>#=> 2</Comment><br/>
<Dec>10</Dec><Normal Text> </Normal Text><Operator>-</Operator><Normal Text> </Normal Text><Dec>5</Dec><Normal Text> </Normal Text><Comment>#=> 5</Comment><br/>
<Dec>5</Dec><Normal Text> </Normal Text><Operator>*</Operator><Normal Text> </Normal Text><Dec>2</Dec><Normal Text>  </Normal Text><Comment>#=> 10</Comment><br/>
<Dec>10</Dec><Normal Text> </Normal Text><Operator>/</Operator><Normal Text> </Normal Text><Dec>2</Dec><Normal Text> </Normal Text><Comment>#=> 5.0</Comment><br/>
<Normal Text></Normal Text><br/>
<Comment># In elixir the operator `/` always returns a float.</Comment><br/>
<Normal Text></Normal Text><br/>
<Comment># To do integer division use `div`</Comment><br/>
<Normal Text>div(</Normal Text><Dec>10</Dec><Normal Text>, </Normal Text><Dec>2</Dec><Normal Text>) </Normal Text><Comment>#=> 5</Comment><br/>
<Normal Text></Normal Text><br/>
<Comment># To get the division remainder use `rem`</Comment><br/>
<Normal Text>rem(</Normal Text><Dec>10</Dec><Normal Text>, </Normal Text><Dec>3</Dec><Normal Text>) </Normal Text><Comment>#=> 1</Comment><br/>
<Normal Text></Normal Text><br/>
<Comment># There are also boolean operators: `or`, `and` and `not`.</Comment><br/>
<Comment># These operators expect a boolean as their first argument.</Comment><br/>
<Pseudo variable>true</Pseudo variable><Normal Text> </Normal Text><Keyword>and</Keyword><Normal Text> </Normal Text><Pseudo variable>true</Pseudo variable><Normal Text> </Normal Text><Comment>#=> true</Comment><br/>
<Pseudo variable>false</Pseudo variable><Normal Text> </Normal Text><Keyword>or</Keyword><Normal Text> </Normal Text><Pseudo variable>true</Pseudo variable><Normal Text> </Normal Text><Comment>#=> true</Comment><br/>
<Comment># 1 and true    #=> ** (ArgumentError) argument error</Comment><br/>
<Normal Text></Normal Text><br/>
<Comment># Elixir also provides `||`, `&&` and `!` which accept arguments of any type.</Comment><br/>
<Comment># All values except `false` and `nil` will evaluate to true.</Comment><br/>
<Dec>1</Dec><Normal Text> </Normal Text><Operator>||</Operator><Normal Text> </Normal Text><Pseudo variable>true</Pseudo variable><Normal Text>  </Normal Text><Comment>#=> 1</Comment><br/>
<Pseudo variable>false</Pseudo variable><Normal Text> </Normal Text><Operator>&&</Operator><Normal Text> </Normal Text><Dec>1</Dec><Normal Text> </Normal Text><Comment>#=> false</Comment><br/>
<Pseudo variable>nil</Pseudo variable><Normal Text> </Normal Text><Operator>&&</Operator><Normal Text> </Normal Text><Dec>20</Dec><Normal Text>  </Normal Text><Comment>#=> nil</Comment><br/>
<Normal Text>!true </Normal Text><Comment>#=> false</Comment><br/>
<Normal Text></Normal Text><br/>
<Comment># For comparisons we have: `==`, `!=`, `===`, `!==`, `<=`, `>=`, `<` and `>`</Comment><br/>
<Dec>1</Dec><Normal Text> </Normal Text><Operator>==</Operator><Normal Text> </Normal Text><Dec>1</Dec><Normal Text> </Normal Text><Comment>#=> true</Comment><br/>
<Dec>1</Dec><Operator> !=</Operator><Normal Text> </Normal Text><Dec>1</Dec><Normal Text> </Normal Text><Comment>#=> false</Comment><br/>
<Dec>1</Dec><Normal Text> </Normal Text><Operator><</Operator><Normal Text> </Normal Text><Dec>2</Dec><Normal Text>  </Normal Text><Comment>#=> true</Comment><br/>
<Normal Text></Normal Text><br/>
<Comment># `===` and `!==` are more strict when comparing integers and floats:</Comment><br/>
<Dec>1</Dec><Normal Text> </Normal Text><Operator>==</Operator><Normal Text> </Normal Text><Float>1.0</Float><Normal Text>  </Normal Text><Comment>#=> true</Comment><br/>
<Dec>1</Dec><Normal Text> </Normal Text><Operator>===</Operator><Normal Text> </Normal Text><Float>1.0</Float><Normal Text> </Normal Text><Comment>#=> false</Comment><br/>
<Normal Text></Normal Text><br/>
<Comment># We can also compare two different data types:</Comment><br/>
<Dec>1</Dec><Normal Text> </Normal Text><Operator><</Operator><Normal Text> </Normal Text><Symbol>:hello</Symbol><Normal Text> </Normal Text><Comment>#=> true</Comment><br/>
<Normal Text></Normal Text><br/>
<Comment># The overall sorting order is defined below:</Comment><br/>
<Comment># number < atom < reference < functions < port < pid < tuple < list < bit string</Comment><br/>
<Normal Text></Normal Text><br/>
<Comment># To quote Joe Armstrong on this: "The actual order is not important,</Comment><br/>
<Comment># but that a total ordering is well defined is important."</Comment><br/>
<Normal Text></Normal Text><br/>
<Comment>## ---------------------------</Comment><br/>
<Comment>## -- Control Flow</Comment><br/>
<Comment>## ---------------------------</Comment><br/>
<Normal Text></Normal Text><br/>
<Comment># `if` expression</Comment><br/>
<Control Flow>if</Control Flow><Normal Text> </Normal Text><Pseudo variable>false</Pseudo variable><Normal Text> </Normal Text><Keyword>do</Keyword><br/>
<Normal Text>  </Normal Text><String>"This will never be seen"</String><br/>
<Control Flow>else</Control Flow><br/>
<Normal Text>  </Normal Text><String>"This will"</String><br/>
<Keyword>end</Keyword><br/>
<Normal Text></Normal Text><br/>
<Comment># There's also `unless`</Comment><br/>
<Control Flow>unless</Control Flow><Normal Text> </Normal Text><Pseudo variable>true</Pseudo variable><Normal Text> </Normal Text><Keyword>do</Keyword><br/>
<Normal Text>  </Normal Text><String>"This will never be seen"</String><br/>
<Control Flow>else</Control Flow><br/>
<Normal Text>  </Normal Text><String>"This will"</String><br/>
<Keyword>end</Keyword><br/>
<Normal Text></Normal Text><br/>
<Comment># Remember pattern matching? Many control-flow structures in elixir rely on it.</Comment><br/>
<Normal Text></Normal Text><br/>
<Comment># `case` allows us to compare a value against many patterns:</Comment><br/>
<Keyword>case</Keyword><Normal Text> {</Normal Text><Symbol>:one</Symbol><Normal Text>, </Normal Text><Symbol>:two</Symbol><Normal Text>} </Normal Text><Keyword>do</Keyword><br/>
<Normal Text>  {</Normal Text><Symbol>:four</Symbol><Normal Text>, </Normal Text><Symbol>:five</Symbol><Normal Text>} </Normal Text><Operator>-></Operator><br/>
<Normal Text>    </Normal Text><String>"This won't match"</String><br/>
<Normal Text>  {</Normal Text><Symbol>:one</Symbol><Normal Text>, x} </Normal Text><Operator>-></Operator><br/>
<Normal Text>    </Normal Text><String>"This will match and bind `x` to `:two`"</String><br/>
<Normal Text>  _ </Normal Text><Operator>-></Operator><br/>
<Normal Text>    </Normal Text><String>"This will match any value"</String><br/>
<Keyword>end</Keyword><br/>
<Normal Text></Normal Text><br/>
<Comment># It's common to bind the value to `_` if we don't need it.</Comment><br/>
<Comment># For example, if only the head of a list matters to us:</Comment><br/>
<Delimiter>[</Delimiter><Normal Text>head </Normal Text><Operator>|</Operator><Normal Text> _</Normal Text><Delimiter>]</Delimiter><Normal Text> </Normal Text><Operator>=</Operator><Normal Text> </Normal Text><Delimiter>[</Delimiter><Dec>1</Dec><Normal Text>,</Normal Text><Dec>2</Dec><Normal Text>,</Normal Text><Dec>3</Dec><Delimiter>]</Delimiter><br/>
<Normal Text>head </Normal Text><Comment>#=> 1</Comment><br/>
<Normal Text></Normal Text><br/>
<Comment># For better readability we can do the following:</Comment><br/>
<Delimiter>[</Delimiter><Normal Text>head </Normal Text><Operator>|</Operator><Normal Text> _tail</Normal Text><Delimiter>]</Delimiter><Normal Text> </Normal Text><Operator>=</Operator><Normal Text> </Normal Text><Delimiter>[</Delimiter><Symbol>:a</Symbol><Normal Text>, </Normal Text><Symbol>:b</Symbol><Normal Text>, </Normal Text><Symbol>:c</Symbol><Delimiter>]</Delimiter><br/>
<Normal Text>head </Normal Text><Comment>#=> :a</Comment><br/>
<Normal Text></Normal Text><br/>
<Comment># `cond` lets us check for many conditions at the same time.</Comment><br/>
<Comment># Use `cond` instead of nesting many `if` expressions.</Comment><br/>
<Control Flow>cond</Control Flow><Normal Text> </Normal Text><Keyword>do</Keyword><br/>
<Normal Text>  </Normal Text><Dec>1</Dec><Normal Text> </Normal Text><Operator>+</Operator><Normal Text> </Normal Text><Dec>1</Dec><Normal Text> </Normal Text><Operator>==</Operator><Normal Text> </Normal Text><Dec>3</Dec><Normal Text> </Normal Text><Operator>-></Operator><br/>
<Normal Text>    </Normal Text><String>"I will never be seen"</String><br/>
<Normal Text>  </Normal Text><Dec>2</Dec><Normal Text> </Normal Text><Operator>*</Operator><Normal Text> </Normal Text><Dec>5</Dec><Normal Text> </Normal Text><Operator>==</Operator><Normal Text> </Normal Text><Dec>12</Dec><Normal Text> </Normal Text><Operator>-></Operator><br/>
<Normal Text>    </Normal Text><String>"Me neither"</String><br/>
<Normal Text>  </Normal Text><Dec>1</Dec><Normal Text> </Normal Text><Operator>+</Operator><Normal Text> </Normal Text><Dec>2</Dec><Normal Text> </Normal Text><Operator>==</Operator><Normal Text> </Normal Text><Dec>3</Dec><Normal Text> </Normal Text><Operator>-></Operator><br/>
<Normal Text>    </Normal Text><String>"But I will"</String><br/>
<Keyword>end</Keyword><br/>
<Normal Text></Normal Text><br/>
<Comment># It is common to set the last condition equal to `true`, which will always match.</Comment><br/>
<Control Flow>cond</Control Flow><Normal Text> </Normal Text><Keyword>do</Keyword><br/>
<Normal Text>  </Normal Text><Dec>1</Dec><Normal Text> </Normal Text><Operator>+</Operator><Normal Text> </Normal Text><Dec>1</Dec><Normal Text> </Normal Text><Operator>==</Operator><Normal Text> </Normal Text><Dec>3</Dec><Normal Text> </Normal Text><Operator>-></Operator><br/>
<Normal Text>    </Normal Text><String>"I will never be seen"</String><br/>
<Normal Text>  </Normal Text><Dec>2</Dec><Normal Text> </Normal Text><Operator>*</Operator><Normal Text> </Normal Text><Dec>5</Dec><Normal Text> </Normal Text><Operator>==</Operator><Normal Text> </Normal Text><Dec>12</Dec><Normal Text> </Normal Text><Operator>-></Operator><br/>
<Normal Text>    </Normal Text><String>"Me neither"</String><br/>
<Normal Text>  </Normal Text><Pseudo variable>true</Pseudo variable><Normal Text> </Normal Text><Operator>-></Operator><br/>
<Normal Text>    </Normal Text><String>"But I will (this is essentially an else)"</String><br/>
<Keyword>end</Keyword><br/>
<Normal Text></Normal Text><br/>
<Comment># `try/catch` is used to catch values that are thrown, it also supports an</Comment><br/>
<Comment># `after` clause that is invoked whether or not a value is caught.</Comment><br/>
<Control Flow>try</Control Flow><Normal Text> </Normal Text><Keyword>do</Keyword><br/>
<Normal Text>  </Normal Text><Control Flow>throw</Control Flow><Normal Text>(</Normal Text><Symbol>:hello</Symbol><Normal Text>)</Normal Text><br/>
<Control Flow>catch</Control Flow><br/>
<Normal Text>  message </Normal Text><Operator>-></Operator><Normal Text> </Normal Text><String>"Got </String><Substitution>#{</Substitution><Normal Text>message</Normal Text><Substitution>}</Substitution><String>."</String><br/>
<Keyword>after</Keyword><br/>
<Normal Text>  </Normal Text><Global Constant>IO</Global Constant><Operator>.</Operator><Normal Text>puts(</Normal Text><String>"I'm the after clause."</String><Normal Text>)</Normal Text><br/>
<Keyword>end</Keyword><br/>
<Comment>#=> I'm the after clause</Comment><br/>
<Comment># "Got :hello"</Comment><br/>
<Normal Text></Normal Text><br/>
<Comment>## ---------------------------</Comment><br/>
<Comment>## -- Modules and Functions</Comment><br/>
<Comment>## ---------------------------</Comment><br/>
<Normal Text></Normal Text><br/>
<Comment># Anonymous functions (notice the dot)</Comment><br/>
<Normal Text>square </Normal Text><Operator>=</Operator><Normal Text> </Normal Text><Definition>fn</Definition><Normal Text>(x) </Normal Text><Operator>-></Operator><Normal Text> x </Normal Text><Operator>*</Operator><Normal Text> x </Normal Text><Keyword>end</Keyword><br/>
<Normal Text>square</Normal Text><Operator>.</Operator><Normal Text>(</Normal Text><Dec>5</Dec><Normal Text>) </Normal Text><Comment>#=> 25</Comment><br/>
<Normal Text></Normal Text><br/>
<Comment># They also accept many clauses and guards.</Comment><br/>
<Comment># Guards let you fine tune pattern matching,</Comment><br/>
<Comment># they are indicated by the `when` keyword:</Comment><br/>
<Normal Text>f </Normal Text><Operator>=</Operator><Normal Text> </Normal Text><Definition>fn</Definition><br/>
<Normal Text>  x, y </Normal Text><Keyword>when</Keyword><Normal Text> x </Normal Text><Operator>></Operator><Normal Text> </Normal Text><Dec>0</Dec><Normal Text> </Normal Text><Operator>-></Operator><Normal Text> x </Normal Text><Operator>+</Operator><Normal Text> y</Normal Text><br/>
<Normal Text>  x, y </Normal Text><Operator>-></Operator><Normal Text> x </Normal Text><Operator>*</Operator><Normal Text> y</Normal Text><br/>
<Keyword>end</Keyword><br/>
<Normal Text></Normal Text><br/>
<Normal Text>f</Normal Text><Operator>.</Operator><Normal Text>(</Normal Text><Dec>1</Dec><Normal Text>, </Normal Text><Dec>3</Dec><Normal Text>)  </Normal Text><Comment>#=> 4</Comment><br/>
<Normal Text>f</Normal Text><Operator>.</Operator><Normal Text>(</Normal Text><Operator>-</Operator><Dec>1</Dec><Normal Text>, </Normal Text><Dec>3</Dec><Normal Text>) </Normal Text><Comment>#=> -3</Comment><br/>
<Normal Text></Normal Text><br/>
<Comment># Elixir also provides many built-in functions.</Comment><br/>
<Comment># These are available in the current scope.</Comment><br/>
<Normal Text>is_number(</Normal Text><Dec>10</Dec><Normal Text>)    </Normal Text><Comment>#=> true</Comment><br/>
<Normal Text>is_list(</Normal Text><String>"hello"</String><Normal Text>) </Normal Text><Comment>#=> false</Comment><br/>
<Normal Text>elem({</Normal Text><Dec>1</Dec><Normal Text>,</Normal Text><Dec>2</Dec><Normal Text>,</Normal Text><Dec>3</Dec><Normal Text>}, </Normal Text><Dec>0</Dec><Normal Text>) </Normal Text><Comment>#=> 1</Comment><br/>
<Normal Text></Normal Text><br/>
<Comment># You can group several functions into a module. Inside a module use `def`</Comment><br/>
<Comment># to define your functions.</Comment><br/>
<Definition>defmodule</Definition><Normal Text> </Normal Text><Constant>Math</Constant><Normal Text> </Normal Text><Keyword>do</Keyword><br/>
<Normal Text>  </Normal Text><Definition>def</Definition><Normal Text> sum(a, b) </Normal Text><Keyword>do</Keyword><br/>
<Normal Text>    a </Normal Text><Operator>+</Operator><Normal Text> b</Normal Text><br/>
<Normal Text>  </Normal Text><Keyword>end</Keyword><br/>
<Normal Text></Normal Text><br/>
<Normal Text>  </Normal Text><Definition>def</Definition><Normal Text> square(x) </Normal Text><Keyword>do</Keyword><br/>
<Normal Text>    x </Normal Text><Operator>*</Operator><Normal Text> x</Normal Text><br/>
<Normal Text>  </Normal Text><Keyword>end</Keyword><br/>
<Keyword>end</Keyword><br/>
<Normal Text></Normal Text><br/>
<Constant>Math</Constant><Operator>.</Operator><Normal Text>sum(</Normal Text><Dec>1</Dec><Normal Text>, </Normal Text><Dec>2</Dec><Normal Text>)  </Normal Text><Comment>#=> 3</Comment><br/>
<Constant>Math</Constant><Operator>.</Operator><Normal Text>square(</Normal Text><Dec>3</Dec><Normal Text>) </Normal Text><Comment>#=> 9</Comment><br/>
<Normal Text></Normal Text><br/>
<Comment># To compile our simple Math module save it as `math.ex` and use `elixirc`</Comment><br/>
<Comment># in your terminal: elixirc math.ex</Comment><br/>
<Normal Text></Normal Text><br/>
<Comment># Inside a module we can define functions with `def` and private functions with `defp`.</Comment><br/>
<Comment># A function defined with `def` is available to be invoked from other modules,</Comment><br/>
<Comment># a private function can only be invoked locally.</Comment><br/>
<Definition>defmodule</Definition><Normal Text> </Normal Text><Constant>PrivateMath</Constant><Normal Text> </Normal Text><Keyword>do</Keyword><br/>
<Normal Text>  </Normal Text><Definition>def</Definition><Normal Text> sum(a, b) </Normal Text><Keyword>do</Keyword><br/>
<Normal Text>    do_sum(a, b)</Normal Text><br/>
<Normal Text>  </Normal Text><Keyword>end</Keyword><br/>
<Normal Text></Normal Text><br/>
<Normal Text>  </Normal Text><Definition>defp</Definition><Normal Text> do_sum(a, b) </Normal Text><Keyword>do</Keyword><br/>
<Normal Text>    a </Normal Text><Operator>+</Operator><Normal Text> b</Normal Text><br/>
<Normal Text>  </Normal Text><Keyword>end</Keyword><br/>
<Keyword>end</Keyword><br/>
<Normal Text></Normal Text><br/>
<Constant>PrivateMath</Constant><Operator>.</Operator><Normal Text>sum(</Normal Text><Dec>1</Dec><Normal Text>, </Normal Text><Dec>2</Dec><Normal Text>)    </Normal Text><Comment>#=> 3</Comment><br/>
<Comment># PrivateMath.do_sum(1, 2) #=> ** (UndefinedFunctionError)</Comment><br/>
<Normal Text></Normal Text><br/>
<Comment># Function declarations also support guards and multiple clauses:</Comment><br/>
<Definition>defmodule</Definition><Normal Text> </Normal Text><Constant>Geometry</Constant><Normal Text> </Normal Text><Keyword>do</Keyword><br/>
<Normal Text>  </Normal Text><Definition>def</Definition><Normal Text> area({</Normal Text><Symbol>:rectangle</Symbol><Normal Text>, w, h}) </Normal Text><Keyword>do</Keyword><br/>
<Normal Text>    w </Normal Text><Operator>*</Operator><Normal Text> h</Normal Text><br/>
<Normal Text>  </Normal Text><Keyword>end</Keyword><br/>
<Normal Text></Normal Text><br/>
<Normal Text>  </Normal Text><Definition>def</Definition><Normal Text> area({</Normal Text><Symbol>:circle</Symbol><Normal Text>, r}) </Normal Text><Keyword>when</Keyword><Normal Text> is_number(r) </Normal Text><Keyword>do</Keyword><br/>
<Normal Text>    </Normal Text><Float>3.14</Float><Normal Text> </Normal Text><Operator>*</Operator><Normal Text> r </Normal Text><Operator>*</Operator><Normal Text> r</Normal Text><br/>
<Normal Text>  </Normal Text><Keyword>end</Keyword><br/>
<Keyword>end</Keyword><br/>
<Normal Text></Normal Text><br/>
<Constant>Geometry</Constant><Operator>.</Operator><Normal Text>area({</Normal Text><Symbol>:rectangle</Symbol><Normal Text>, </Normal Text><Dec>2</Dec><Normal Text>, </Normal Text><Dec>3</Dec><Normal Text>}) </Normal Text><Comment>#=> 6</Comment><br/>
<Constant>Geometry</Constant><Operator>.</Operator><Normal Text>area({</Normal Text><Symbol>:circle</Symbol><Normal Text>, </Normal Text><Dec>3</Dec><Normal Text>})       </Normal Text><Comment>#=> 28.25999999999999801048</Comment><br/>
<Comment># Geometry.area({:circle, "not_a_number"})</Comment><br/>
<Comment>#=> ** (FunctionClauseError) no function clause matching in Geometry.area/1</Comment><br/>
<Normal Text></Normal Text><br/>
<Comment># Due to immutability, recursion is a big part of elixir</Comment><br/>
<Definition>defmodule</Definition><Normal Text> </Normal Text><Constant>Recursion</Constant><Normal Text> </Normal Text><Keyword>do</Keyword><br/>
<Normal Text>  </Normal Text><Definition>def</Definition><Normal Text> sum_list(</Normal Text><Delimiter>[</Delimiter><Normal Text>head </Normal Text><Operator>|</Operator><Normal Text> tail</Normal Text><Delimiter>]</Delimiter><Normal Text>, acc) </Normal Text><Keyword>do</Keyword><br/>
<Normal Text>    sum_list(tail, acc </Normal Text><Operator>+</Operator><Normal Text> head)</Normal Text><br/>
<Normal Text>  </Normal Text><Keyword>end</Keyword><br/>
<Normal Text></Normal Text><br/>
<Normal Text>  </Normal Text><Definition>def</Definition><Normal Text> sum_list(</Normal Text><Delimiter>[]</Delimiter><Normal Text>, acc) </Normal Text><Keyword>do</Keyword><br/>
<Normal Text>    acc</Normal Text><br/>
<Normal Text>  </Normal Text><Keyword>end</Keyword><br/>
<Keyword>end</Keyword><br/>
<Normal Text></Normal Text><br/>
<Constant>Recursion</Constant><Operator>.</Operator><Normal Text>sum_list(</Normal Text><Delimiter>[</Delimiter><Dec>1</Dec><Normal Text>,</Normal Text><Dec>2</Dec><Normal Text>,</Normal Text><Dec>3</Dec><Delimiter>]</Delimiter><Normal Text>, </Normal Text><Dec>0</Dec><Normal Text>) </Normal Text><Comment>#=> 6</Comment><br/>
<Normal Text></Normal Text><br/>
<Comment># Elixir modules support attributes, there are built-in attributes and you</Comment><br/>
<Comment># may also add custom ones.</Comment><br/>
<Definition>defmodule</Definition><Normal Text> </Normal Text><Constant>MyMod</Constant><Normal Text> </Normal Text><Keyword>do</Keyword><br/>
<Normal Text>  </Normal Text><Attribute>@moduledoc """</Attribute><br/>
<DocComment>  This is a built-in attribute on a example module.</DocComment><br/>
<DocComment>  </DocComment><Attribute>"""</Attribute><br/>
<Normal Text></Normal Text><br/>
<Normal Text>  </Normal Text><Attribute>@my_data</Attribute><Normal Text> </Normal Text><Dec>100</Dec><Normal Text> </Normal Text><Comment># This is a custom attribute.</Comment><br/>
<Normal Text>  </Normal Text><Global Constant>IO</Global Constant><Operator>.</Operator><Normal Text>inspect(</Normal Text><Attribute>@my_data</Attribute><Normal Text>) </Normal Text><Comment>#=> 100</Comment><br/>
<Keyword>end</Keyword><br/>
<Normal Text></Normal Text><br/>
<Comment>## ---------------------------</Comment><br/>
<Comment>## -- Structs and Exceptions</Comment><br/>
<Comment>## ---------------------------</Comment><br/>
<Normal Text></Normal Text><br/>
<Comment># Structs are extensions on top of maps that bring default values,</Comment><br/>
<Comment># compile-time guarantees and polymorphism into Elixir.</Comment><br/>
<Definition>defmodule</Definition><Normal Text> </Normal Text><Constant>Person</Constant><Normal Text> </Normal Text><Keyword>do</Keyword><br/>
<Normal Text>  </Normal Text><Definition>defstruct</Definition><Normal Text> </Normal Text><Symbol>name:</Symbol><Normal Text> </Normal Text><Pseudo variable>nil</Pseudo variable><Normal Text>, </Normal Text><Symbol>age:</Symbol><Normal Text> </Normal Text><Dec>0</Dec><Normal Text>, </Normal Text><Symbol>height:</Symbol><Normal Text> </Normal Text><Dec>0</Dec><br/>
<Keyword>end</Keyword><br/>
<Normal Text></Normal Text><br/>
<Normal Text>joe_info </Normal Text><Operator>=</Operator><Normal Text> %</Normal Text><Constant>Person</Constant><Normal Text>{ </Normal Text><Symbol>name:</Symbol><Normal Text> </Normal Text><String>"Joe"</String><Normal Text>, </Normal Text><Symbol>age:</Symbol><Normal Text> </Normal Text><Dec>30</Dec><Normal Text>, </Normal Text><Symbol>height:</Symbol><Normal Text> </Normal Text><Dec>180</Dec><Normal Text> }</Normal Text><br/>
<Comment>#=> %Person{age: 30, height: 180, name: "Joe"}</Comment><br/>
<Normal Text></Normal Text><br/>
<Comment># Access the value of name</Comment><br/>
<Normal Text>joe_info</Normal Text><Operator>.</Operator><Normal Text>name </Normal Text><Comment>#=> "Joe"</Comment><br/>
<Normal Text></Normal Text><br/>
<Comment># Update the value of age</Comment><br/>
<Normal Text>older_joe_info </Normal Text><Operator>=</Operator><Normal Text> %{ joe_info </Normal Text><Operator>|</Operator><Normal Text> </Normal Text><Symbol>age:</Symbol><Normal Text> </Normal Text><Dec>31</Dec><Normal Text> }</Normal Text><br/>
<Comment>#=> %Person{age: 31, height: 180, name: "Joe"}</Comment><br/>
<Normal Text></Normal Text><br/>
<Comment># The `try` block with the `rescue` keyword is used to handle exceptions</Comment><br/>
<Control Flow>try</Control Flow><Normal Text> </Normal Text><Keyword>do</Keyword><br/>
<Normal Text>  </Normal Text><Control Flow>raise</Control Flow><Normal Text> </Normal Text><String>"some error"</String><br/>
<Control Flow>rescue</Control Flow><br/>
<Normal Text>  </Normal Text><Constant>RuntimeError</Constant><Normal Text> </Normal Text><Operator>-></Operator><Normal Text> </Normal Text><String>"rescued a runtime error"</String><br/>
<Normal Text>  _error </Normal Text><Operator>-></Operator><Normal Text> </Normal Text><String>"this will rescue any error"</String><br/>
<Keyword>end</Keyword><br/>
<Comment>#=> "rescued a runtime error"</Comment><br/>
<Normal Text></Normal Text><br/>
<Comment># All exceptions have a message</Comment><br/>
<Control Flow>try</Control Flow><Normal Text> </Normal Text><Keyword>do</Keyword><br/>
<Normal Text>  </Normal Text><Control Flow>raise</Control Flow><Normal Text> </Normal Text><String>"some error"</String><br/>
<Control Flow>rescue</Control Flow><br/>
<Normal Text>  x </Normal Text><Keyword>in</Keyword><Normal Text> </Normal Text><Delimiter>[</Delimiter><Constant>RuntimeError</Constant><Delimiter>]</Delimiter><Normal Text> </Normal Text><Operator>-></Operator><br/>
<Normal Text>    x</Normal Text><Operator>.</Operator><Normal Text>message</Normal Text><br/>
<Keyword>end</Keyword><br/>
<Comment>#=> "some error"</Comment><br/>
<Normal Text></Normal Text><br/>
<Comment>## ---------------------------</Comment><br/>
<Comment>## -- Concurrency</Comment><br/>
<Comment>## ---------------------------</Comment><br/>
<Normal Text></Normal Text><br/>
<Comment># Elixir relies on the actor model for concurrency. All we need to write</Comment><br/>
<Comment># concurrent programs in elixir are three primitives: spawning processes,</Comment><br/>
<Comment># sending messages and receiving messages.</Comment><br/>
<Normal Text></Normal Text><br/>
<Comment># To start a new process we use the `spawn` function, which takes a function</Comment><br/>
<Comment># as argument.</Comment><br/>
<Normal Text>f </Normal Text><Operator>=</Operator><Normal Text> </Normal Text><Definition>fn</Definition><Normal Text> </Normal Text><Operator>-></Operator><Normal Text> </Normal Text><Dec>2</Dec><Normal Text> </Normal Text><Operator>*</Operator><Normal Text> </Normal Text><Dec>2</Dec><Normal Text> </Normal Text><Keyword>end</Keyword><Normal Text> </Normal Text><Comment>#=> #Function<erl_eval.20.80484245></Comment><br/>
<Normal Text>spawn(f) </Normal Text><Comment>#=> #PID<0.40.0></Comment><br/>
<Normal Text></Normal Text><br/>
<Comment># `spawn` returns a pid (process identifier), you can use this pid to send</Comment><br/>
<Comment># messages to the process. To do message passing we use the `send` operator.</Comment><br/>
<Comment># For all of this to be useful we need to be able to receive messages. This is</Comment><br/>
<Comment># achieved with the `receive` mechanism:</Comment><br/>
<Normal Text></Normal Text><br/>
<Comment># The `receive do` block is used to listen for messages and process</Comment><br/>
<Comment># them when they are received. A `receive do` block will only</Comment><br/>
<Comment># process one received message. In order to process multiple</Comment><br/>
<Comment># messages, a function with a `receive do` block must recursively</Comment><br/>
<Comment># call itself to get into the `receive do` block again.</Comment><br/>
<Normal Text></Normal Text><br/>
<Definition>defmodule</Definition><Normal Text> </Normal Text><Constant>Geometry</Constant><Normal Text> </Normal Text><Keyword>do</Keyword><br/>
<Normal Text>  </Normal Text><Definition>def</Definition><Normal Text> area_loop </Normal Text><Keyword>do</Keyword><br/>
<Normal Text>    </Normal Text><Keyword>receive</Keyword><Normal Text> </Normal Text><Keyword>do</Keyword><br/>
<Normal Text>      {</Normal Text><Symbol>:rectangle</Symbol><Normal Text>, w, h} </Normal Text><Operator>-></Operator><br/>
<Normal Text>        </Normal Text><Global Constant>IO</Global Constant><Operator>.</Operator><Normal Text>puts(</Normal Text><String>"Area = </String><Substitution>#{</Substitution><Normal Text>w </Normal Text><Operator>*</Operator><Normal Text> h</Normal Text><Substitution>}</Substitution><String>"</String><Normal Text>)</Normal Text><br/>
<Normal Text>        area_loop()</Normal Text><br/>
<Normal Text>      {</Normal Text><Symbol>:circle</Symbol><Normal Text>, r} </Normal Text><Operator>-></Operator><br/>
<Normal Text>        </Normal Text><Global Constant>IO</Global Constant><Operator>.</Operator><Normal Text>puts(</Normal Text><String>"Area = </String><Substitution>#{</Substitution><Float>3.14</Float><Normal Text> </Normal Text><Operator>*</Operator><Normal Text> r </Normal Text><Operator>*</Operator><Normal Text> r</Normal Text><Substitution>}</Substitution><String>"</String><Normal Text>)</Normal Text><br/>
<Normal Text>        area_loop()</Normal Text><br/>
<Normal Text>    </Normal Text><Keyword>end</Keyword><br/>
<Normal Text>  </Normal Text><Keyword>end</Keyword><br/>
<Keyword>end</Keyword><br/>
<Normal Text></Normal Text><br/>
<Comment># Compile the module and create a process that evaluates `area_loop` in the shell</Comment><br/>
<Normal Text>pid </Normal Text><Operator>=</Operator><Normal Text> spawn(</Normal Text><Definition>fn</Definition><Normal Text> </Normal Text><Operator>-></Operator><Normal Text> </Normal Text><Constant>Geometry</Constant><Operator>.</Operator><Normal Text>area_loop() </Normal Text><Keyword>end</Keyword><Normal Text>) </Normal Text><Comment>#=> #PID<0.40.0></Comment><br/>
<Comment># Alternatively</Comment><br/>
<Normal Text>pid </Normal Text><Operator>=</Operator><Normal Text> spawn(</Normal Text><Constant>Geometry</Constant><Normal Text>, </Normal Text><Symbol>:area_loop</Symbol><Normal Text>, </Normal Text><Delimiter>[]</Delimiter><Normal Text>)</Normal Text><br/>
<Normal Text></Normal Text><br/>
<Comment># Send a message to `pid` that will match a pattern in the receive statement</Comment><br/>
<Normal Text>send pid, {</Normal Text><Symbol>:rectangle</Symbol><Normal Text>, </Normal Text><Dec>2</Dec><Normal Text>, </Normal Text><Dec>3</Dec><Normal Text>}</Normal Text><br/>
<Comment>#=> Area = 6</Comment><br/>
<Comment>#   {:rectangle,2,3}</Comment><br/>
<Normal Text></Normal Text><br/>
<Normal Text>send pid, {</Normal Text><Symbol>:circle</Symbol><Normal Text>, </Normal Text><Dec>2</Dec><Normal Text>}</Normal Text><br/>
<Comment>#=> Area = 12.56000000000000049738</Comment><br/>
<Comment>#   {:circle,2}</Comment><br/>
<Normal Text></Normal Text><br/>
<Comment># The shell is also a process, you can use `self` to get the current pid</Comment><br/>
<Normal Text>self() </Normal Text><Comment>#=> #PID<0.27.0></Comment><br/>
